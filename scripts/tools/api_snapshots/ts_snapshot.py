#!/usr/bin/env python3

from __future__ import annotations

import hashlib
import re
import sys
from pathlib import Path


EXPORT_DECL_RE = re.compile(
    r"^\s*export\s+(?:declare\s+)?(interface|class|function|type|const|let|var|enum|namespace)\s+([A-Za-z0-9_]+)\b"
)
EXPORT_LIST_RE = re.compile(
    r"^\s*export\s+(?:type\s+)?\{([^}]*)\}\s*(?:from\s+['\"]([^'\"]+)['\"])?\s*;?\s*$"
)
EXPORT_STAR_RE = re.compile(r"^\s*export\s+\*\s+from\s+['\"]([^'\"]+)['\"]\s*;?\s*$")


def sha256_hex(data: bytes) -> str:
    h = hashlib.sha256()
    h.update(data)
    return h.hexdigest()


def _parse_export_list(raw: str) -> list[tuple[str, str]]:
    out: list[tuple[str, str]] = []
    for part in raw.split(","):
        part = part.strip()
        if not part:
            continue

        if part.startswith("type "):
            part = part[len("type ") :].strip()

        if " as " in part:
            name, alias = part.split(" as ", 1)
            out.append((name.strip(), alias.strip()))
        else:
            out.append((part, part))
    return out


def _resolve_module_spec(from_file: Path, spec: str) -> Path | None:
    if not spec.startswith("."):
        return None
    target = (from_file.parent / spec).resolve()
    if target.suffix == ".js":
        target = target.with_suffix(".d.ts")
    elif target.suffix == ".mjs":
        target = target.with_suffix(".d.ts")
    elif target.suffix == "":
        target = target.with_suffix(".d.ts")
    return target


def collect_exports(entry: Path) -> tuple[list[tuple[str, str]], list[str]]:
    passthrough: set[str] = set()
    cache: dict[Path, dict[str, set[str]]] = {}
    stack: set[Path] = set()

    def module_exports(file_path: Path) -> dict[str, set[str]]:
        resolved = file_path.resolve()
        cached = cache.get(resolved)
        if cached is not None:
            return cached
        if resolved in stack:
            return {}

        stack.add(resolved)

        out: dict[str, set[str]] = {}

        def add(name: str, kind: str) -> None:
            out.setdefault(name, set()).add(kind)

        try:
            text = resolved.read_text("utf-8")
        except FileNotFoundError:
            passthrough.add(f"# missing: {resolved.as_posix()}")
            cache[resolved] = {}
            stack.remove(resolved)
            return {}

        for line in text.splitlines():
            m = EXPORT_DECL_RE.match(line)
            if m:
                add(m.group(2), m.group(1))
                continue

            m = EXPORT_STAR_RE.match(line)
            if m:
                spec = m.group(1)
                target = _resolve_module_spec(resolved, spec)
                if target is None:
                    passthrough.add(line.strip())
                    continue
                for name, kinds in module_exports(target).items():
                    out.setdefault(name, set()).update(kinds)
                continue

            m = EXPORT_LIST_RE.match(line)
            if m:
                raw = m.group(1).strip()
                spec = m.group(2)
                if not raw:
                    continue

                parts = _parse_export_list(raw)
                if not spec:
                    for _, alias in parts:
                        add(alias, "re-export")
                    continue

                target = _resolve_module_spec(resolved, spec)
                if target is None:
                    for _, alias in parts:
                        add(alias, "re-export")
                    continue

                target_exports = module_exports(target)
                for original, alias in parts:
                    kinds = target_exports.get(original)
                    if not kinds:
                        add(alias, "re-export")
                        continue
                    out.setdefault(alias, set()).update(kinds)

        cache[resolved] = out
        stack.remove(resolved)
        return out

    exports = module_exports(entry)

    flattened: list[tuple[str, str]] = []
    for name, kinds in exports.items():
        for kind in kinds:
            flattened.append((name, kind))

    flattened.sort(key=lambda x: (x[0], x[1]))
    passthrough_list = sorted(passthrough)
    return flattened, passthrough_list


def main() -> int:
    src = Path(sys.argv[1] if len(sys.argv) > 1 else "ts/dist/index.d.ts")
    data = src.read_bytes()
    text = data.decode("utf-8")

    exports, passthrough = collect_exports(src)

    sys.stdout.write("# AppTheory TypeScript public API snapshot\n")
    sys.stdout.write(f"# Source: {src.as_posix()}\n")
    sys.stdout.write(f"# SHA256: {sha256_hex(data)}\n")
    sys.stdout.write("# Generated by: scripts/update-api-snapshots.sh\n")
    sys.stdout.write("# DO NOT EDIT MANUALLY\n\n")

    sys.stdout.write("[exports]\n")
    for name, kind in exports:
        sys.stdout.write(f"{name}\t{kind}\n")

    if passthrough:
        sys.stdout.write("\n[export-statements]\n")
        for stmt in passthrough:
            sys.stdout.write(f"{stmt}\n")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
