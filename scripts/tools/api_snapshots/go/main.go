package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
)

type goListPackage struct {
	ImportPath string `json:"ImportPath"`
	Dir        string `json:"Dir"`
	GoFiles    []string
	CgoFiles   []string
	Error      *struct {
		Err string
	}
}

type exportDecl struct {
	Kind string
	Name string
	Decl string
}

func main() {
	pkgs, err := listPackages()
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}

	sort.Slice(pkgs, func(i, j int) bool {
		return pkgs[i].ImportPath < pkgs[j].ImportPath
	})

	w := bufio.NewWriter(os.Stdout)
	defer w.Flush()

	fmt.Fprintln(w, "# AppTheory Go public API snapshot")
	fmt.Fprintln(w, "# Scope: ./runtime/... ./pkg/... ./testkit/...")
	fmt.Fprintf(w, "# Go version: %s\n", runtime.Version())
	fmt.Fprintln(w, "# Generated by: scripts/update-api-snapshots.sh")
	fmt.Fprintln(w, "# DO NOT EDIT MANUALLY")

	for _, pkg := range pkgs {
		exports, err := snapshotPackage(pkg)
		if err != nil {
			fmt.Fprintf(os.Stderr, "go-api-snapshot: FAIL (%s): %s\n", pkg.ImportPath, err.Error())
			os.Exit(1)
		}
		if len(exports) == 0 {
			continue
		}

		fmt.Fprintln(w)
		fmt.Fprintf(w, "## %s\n", pkg.ImportPath)

		for _, e := range exports {
			fmt.Fprintln(w)
			fmt.Fprintln(w, strings.TrimRight(e.Decl, "\n"))
		}
	}
}

func listPackages() ([]goListPackage, error) {
	cmd := exec.Command("go", "list", "-json", "./runtime/...", "./pkg/...", "./testkit/...")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	out, err := cmd.Output()
	if err != nil {
		if ee := (&exec.ExitError{}); errorAs(err, &ee) {
			return nil, fmt.Errorf("go-api-snapshot: FAIL (go list): %s", strings.TrimSpace(stderr.String()))
		}
		return nil, fmt.Errorf("go-api-snapshot: FAIL (go list): %s", err.Error())
	}

	dec := json.NewDecoder(bytes.NewReader(out))
	pkgs := make([]goListPackage, 0, 64)
	for {
		var p goListPackage
		if err := dec.Decode(&p); err != nil {
			if err == io.EOF {
				break
			}
			return nil, fmt.Errorf("go-api-snapshot: FAIL (decode go list output): %s", err.Error())
		}
		if p.Error != nil && p.Error.Err != "" {
			return nil, fmt.Errorf("go-api-snapshot: FAIL (go list package error): %s: %s", p.ImportPath, p.Error.Err)
		}
		if p.ImportPath == "" || p.Dir == "" {
			continue
		}
		pkgs = append(pkgs, p)
	}
	return pkgs, nil
}

func snapshotPackage(pkg goListPackage) ([]exportDecl, error) {
	files := make([]string, 0, len(pkg.GoFiles)+len(pkg.CgoFiles))
	files = append(files, pkg.GoFiles...)
	files = append(files, pkg.CgoFiles...)
	if len(files) == 0 {
		return nil, nil
	}

	fset := token.NewFileSet()
	asts := make([]*ast.File, 0, len(files))
	for _, name := range files {
		path := filepath.Join(pkg.Dir, name)
		f, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			return nil, err
		}
		normalizeFileForSnapshot(f)
		asts = append(asts, f)
	}

	exports := make([]exportDecl, 0, 256)
	for _, f := range asts {
		for _, decl := range f.Decls {
			switch d := decl.(type) {
			case *ast.FuncDecl:
				if !ast.IsExported(d.Name.Name) {
					continue
				}
				exports = append(exports, exportDecl{
					Kind: funcDeclKind(d),
					Name: funcDeclName(d),
					Decl: formatFuncDecl(fset, d),
				})
			case *ast.GenDecl:
				switch d.Tok {
				case token.TYPE:
					for _, spec := range d.Specs {
						ts, ok := spec.(*ast.TypeSpec)
						if !ok {
							continue
						}
						if !ast.IsExported(ts.Name.Name) {
							continue
						}
						exports = append(exports, exportDecl{
							Kind: "type",
							Name: ts.Name.Name,
							Decl: formatTypeSpec(fset, ts),
						})
					}
				case token.VAR, token.CONST:
					for _, spec := range d.Specs {
						vs, ok := spec.(*ast.ValueSpec)
						if !ok {
							continue
						}
						exports = append(exports, formatValueSpecExports(fset, d.Tok, vs)...)
					}
				}
			}
		}
	}

	// Deduplicate in case of weird build setups.
	byKey := map[string]exportDecl{}
	for _, e := range exports {
		key := e.Kind + "\x00" + e.Name + "\x00" + e.Decl
		byKey[key] = e
	}

	uniq := make([]exportDecl, 0, len(byKey))
	for _, e := range byKey {
		uniq = append(uniq, e)
	}

	kindOrder := map[string]int{
		"const":  1,
		"var":    2,
		"type":   3,
		"func":   4,
		"method": 5,
	}
	sort.Slice(uniq, func(i, j int) bool {
		ki, kj := kindOrder[uniq[i].Kind], kindOrder[uniq[j].Kind]
		if ki != kj {
			return ki < kj
		}
		if uniq[i].Name != uniq[j].Name {
			return uniq[i].Name < uniq[j].Name
		}
		return uniq[i].Decl < uniq[j].Decl
	})
	return uniq, nil
}

func normalizeFileForSnapshot(file *ast.File) {
	ast.Inspect(file, func(node ast.Node) bool {
		ft, ok := node.(*ast.FuncType)
		if !ok {
			return true
		}
		// IMPORTANT: do not touch ft.TypeParams. Type parameter names may be referenced in
		// parameter/result types and cannot be safely anonymized.
		ft.Params = normalizeFieldList(ft.Params)
		ft.Results = normalizeFieldList(ft.Results)
		return true
	})
}

func normalizeFieldList(list *ast.FieldList) *ast.FieldList {
	if list == nil || len(list.List) == 0 {
		return list
	}
	out := &ast.FieldList{Opening: list.Opening, Closing: list.Closing}
	for _, field := range list.List {
		n := 1
		if len(field.Names) > 0 {
			n = len(field.Names)
		}
		for i := 0; i < n; i++ {
			out.List = append(out.List, &ast.Field{Type: field.Type})
		}
	}
	return out
}

func funcDeclKind(d *ast.FuncDecl) string {
	if d.Recv == nil {
		return "func"
	}
	return "method"
}

func funcDeclName(d *ast.FuncDecl) string {
	if d.Recv == nil {
		return d.Name.Name
	}
	recv := receiverTypeString(d.Recv)
	return recv + "." + d.Name.Name
}

func receiverTypeString(recv *ast.FieldList) string {
	if recv == nil || len(recv.List) == 0 {
		return "(unknown)"
	}
	var buf bytes.Buffer
	// Omit receiver names for stability.
	f := &ast.Field{Type: recv.List[0].Type}
	if err := format.Node(&buf, token.NewFileSet(), f.Type); err != nil {
		return "(unknown)"
	}
	return strings.TrimSpace(buf.String())
}

func formatFuncDecl(fset *token.FileSet, d *ast.FuncDecl) string {
	clone := *d
	clone.Body = nil
	if clone.Recv != nil {
		clone.Recv = &ast.FieldList{Opening: clone.Recv.Opening, Closing: clone.Recv.Closing}
		for _, field := range d.Recv.List {
			clone.Recv.List = append(clone.Recv.List, &ast.Field{Type: field.Type})
		}
	}

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, &clone); err != nil {
		return fmt.Sprintf("/* format error: %v */", err)
	}
	return strings.TrimSpace(buf.String())
}

func formatTypeSpec(fset *token.FileSet, ts *ast.TypeSpec) string {
	clone := *ts
	clone.Doc = nil
	clone.Comment = nil
	gen := &ast.GenDecl{Tok: token.TYPE, Specs: []ast.Spec{&clone}}

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, gen); err != nil {
		return fmt.Sprintf("/* format error: %v */", err)
	}
	return strings.TrimSpace(buf.String())
}

func formatValueSpecExports(fset *token.FileSet, tok token.Token, vs *ast.ValueSpec) []exportDecl {
	if len(vs.Names) == 0 {
		return nil
	}

	exported := make([]int, 0, len(vs.Names))
	for i, name := range vs.Names {
		if ast.IsExported(name.Name) {
			exported = append(exported, i)
		}
	}
	if len(exported) == 0 {
		return nil
	}

	kind := "var"
	if tok == token.CONST {
		kind = "const"
	}

	if len(vs.Names) == 1 {
		return []exportDecl{
			{
				Kind: kind,
				Name: vs.Names[0].Name,
				Decl: formatValueSpec(fset, tok, vs),
			},
		}
	}

	if len(vs.Values) == 0 || len(vs.Values) == len(vs.Names) {
		out := make([]exportDecl, 0, len(exported))
		for _, idx := range exported {
			s := &ast.ValueSpec{
				Names: []*ast.Ident{{Name: vs.Names[idx].Name}},
				Type:  vs.Type,
			}
			if len(vs.Values) == len(vs.Names) {
				s.Values = []ast.Expr{vs.Values[idx]}
			}
			out = append(out, exportDecl{
				Kind: kind,
				Name: vs.Names[idx].Name,
				Decl: formatValueSpec(fset, tok, s),
			})
		}
		return out
	}

	// Fallback: keep the combined spec. This can include unexported names in rare
	// multi-value assignment cases, but preserves a faithful signature.
	return []exportDecl{
		{
			Kind: kind,
			Name: vs.Names[exported[0]].Name,
			Decl: formatValueSpec(fset, tok, vs),
		},
	}
}

func formatValueSpec(fset *token.FileSet, tok token.Token, vs *ast.ValueSpec) string {
	clone := *vs
	clone.Doc = nil
	clone.Comment = nil
	gen := &ast.GenDecl{Tok: tok, Specs: []ast.Spec{&clone}}
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, gen); err != nil {
		return fmt.Sprintf("/* format error: %v */", err)
	}
	return strings.TrimSpace(buf.String())
}

// errorAs avoids importing errors for a single usage to keep the tool tiny.
func errorAs(err error, target any) bool {
	switch t := target.(type) {
	case **exec.ExitError:
		if ee, ok := err.(*exec.ExitError); ok {
			*t = ee
			return true
		}
	}
	return false
}

