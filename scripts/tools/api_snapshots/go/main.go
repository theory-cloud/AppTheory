package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
)

type goListPackage struct {
	ImportPath string `json:"ImportPath"`
	Dir        string `json:"Dir"`
	GoFiles    []string
	CgoFiles   []string
	Error      *struct {
		Err string
	}
}

type exportDecl struct {
	Kind string
	Name string
	Decl string
}

const unknownReceiverType = "(unknown)"

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}
}

type errWriter struct {
	w   io.Writer
	err error
}

func (w *errWriter) Println(a ...any) {
	if w.err != nil {
		return
	}
	_, w.err = fmt.Fprintln(w.w, a...)
}

func (w *errWriter) Printf(format string, a ...any) {
	if w.err != nil {
		return
	}
	_, w.err = fmt.Fprintf(w.w, format, a...)
}

func (w *errWriter) Err() error {
	return w.err
}

func run() (err error) {
	pkgs, err := listPackages(context.Background())
	if err != nil {
		return err
	}

	sort.Slice(pkgs, func(i, j int) bool {
		return pkgs[i].ImportPath < pkgs[j].ImportPath
	})

	w := bufio.NewWriter(os.Stdout)
	defer func() {
		if flushErr := w.Flush(); flushErr != nil && err == nil {
			err = flushErr
		}
	}()

	ew := &errWriter{w: w}
	ew.Println("# AppTheory Go public API snapshot")
	ew.Println("# Scope: ./runtime/... ./pkg/... ./testkit/...")
	ew.Printf("# Go version: %s\n", runtime.Version())
	ew.Println("# Generated by: scripts/update-api-snapshots.sh")
	ew.Println("# DO NOT EDIT MANUALLY")

	for _, pkg := range pkgs {
		exports, err := snapshotPackage(pkg)
		if err != nil {
			return fmt.Errorf("go-api-snapshot: FAIL (%s): %w", pkg.ImportPath, err)
		}
		if len(exports) == 0 {
			continue
		}

		ew.Println()
		ew.Printf("## %s\n", pkg.ImportPath)

		for _, e := range exports {
			ew.Println()
			ew.Println(strings.TrimRight(e.Decl, "\n"))
		}

		if err := ew.Err(); err != nil {
			return err
		}
	}

	return ew.Err()
}

func listPackages(ctx context.Context) ([]goListPackage, error) {
	cmd := exec.CommandContext(ctx, "go", "list", "-json", "./runtime/...", "./pkg/...", "./testkit/...")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	out, err := cmd.Output()
	if err != nil {
		var ee *exec.ExitError
		if errors.As(err, &ee) {
			return nil, fmt.Errorf("go-api-snapshot: FAIL (go list): %s", strings.TrimSpace(stderr.String()))
		}
		return nil, fmt.Errorf("go-api-snapshot: FAIL (go list): %s", err.Error())
	}

	dec := json.NewDecoder(bytes.NewReader(out))
	pkgs := make([]goListPackage, 0, 64)
	for {
		var p goListPackage
		if err := dec.Decode(&p); err != nil {
			if err == io.EOF {
				break
			}
			return nil, fmt.Errorf("go-api-snapshot: FAIL (decode go list output): %s", err.Error())
		}
		if p.Error != nil && p.Error.Err != "" {
			return nil, fmt.Errorf("go-api-snapshot: FAIL (go list package error): %s: %s", p.ImportPath, p.Error.Err)
		}
		if p.ImportPath == "" || p.Dir == "" {
			continue
		}
		pkgs = append(pkgs, p)
	}
	return pkgs, nil
}

func snapshotPackage(pkg goListPackage) ([]exportDecl, error) {
	files := packageFiles(pkg)
	if len(files) == 0 {
		return nil, nil
	}

	fset, asts, err := parseAndNormalizeFiles(pkg.Dir, files)
	if err != nil {
		return nil, err
	}

	exports := collectExports(fset, asts)

	// Deduplicate in case of weird build setups.
	uniq := dedupeExports(exports)
	sortExports(uniq)
	return uniq, nil
}

func packageFiles(pkg goListPackage) []string {
	files := make([]string, 0, len(pkg.GoFiles)+len(pkg.CgoFiles))
	files = append(files, pkg.GoFiles...)
	files = append(files, pkg.CgoFiles...)
	return files
}

func parseAndNormalizeFiles(dir string, files []string) (*token.FileSet, []*ast.File, error) {
	fset := token.NewFileSet()
	asts := make([]*ast.File, 0, len(files))
	for _, name := range files {
		path := filepath.Join(dir, name)
		f, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			return nil, nil, err
		}
		normalizeFileForSnapshot(f)
		asts = append(asts, f)
	}
	return fset, asts, nil
}

func collectExports(fset *token.FileSet, files []*ast.File) []exportDecl {
	exports := make([]exportDecl, 0, 256)
	for _, f := range files {
		exports = append(exports, collectFileExports(fset, f)...)
	}
	return exports
}

func collectFileExports(fset *token.FileSet, file *ast.File) []exportDecl {
	exports := make([]exportDecl, 0, 64)
	for _, decl := range file.Decls {
		exports = append(exports, collectDeclExports(fset, decl)...)
	}
	return exports
}

func collectDeclExports(fset *token.FileSet, decl ast.Decl) []exportDecl {
	switch d := decl.(type) {
	case *ast.FuncDecl:
		return collectFuncDeclExports(fset, d)
	case *ast.GenDecl:
		return collectGenDeclExports(fset, d)
	default:
		return nil
	}
}

func collectFuncDeclExports(fset *token.FileSet, d *ast.FuncDecl) []exportDecl {
	if !ast.IsExported(d.Name.Name) {
		return nil
	}
	return []exportDecl{
		{
			Kind: funcDeclKind(d),
			Name: funcDeclName(d),
			Decl: formatFuncDecl(fset, d),
		},
	}
}

func collectGenDeclExports(fset *token.FileSet, d *ast.GenDecl) []exportDecl {
	switch d.Tok {
	case token.TYPE:
		return collectTypeSpecExports(fset, d)
	case token.VAR, token.CONST:
		return collectValueSpecExports(fset, d)
	default:
		return nil
	}
}

func collectTypeSpecExports(fset *token.FileSet, d *ast.GenDecl) []exportDecl {
	exports := make([]exportDecl, 0, len(d.Specs))
	for _, spec := range d.Specs {
		ts, ok := spec.(*ast.TypeSpec)
		if !ok {
			continue
		}
		if !ast.IsExported(ts.Name.Name) {
			continue
		}
		exports = append(exports, exportDecl{
			Kind: "type",
			Name: ts.Name.Name,
			Decl: formatTypeSpec(fset, ts),
		})
	}
	return exports
}

func collectValueSpecExports(fset *token.FileSet, d *ast.GenDecl) []exportDecl {
	exports := make([]exportDecl, 0, len(d.Specs))
	for _, spec := range d.Specs {
		vs, ok := spec.(*ast.ValueSpec)
		if !ok {
			continue
		}
		exports = append(exports, formatValueSpecExports(fset, d.Tok, vs)...)
	}
	return exports
}

func dedupeExports(exports []exportDecl) []exportDecl {
	byKey := make(map[string]exportDecl, len(exports))
	for _, e := range exports {
		key := e.Kind + "\x00" + e.Name + "\x00" + e.Decl
		byKey[key] = e
	}

	uniq := make([]exportDecl, 0, len(byKey))
	for _, e := range byKey {
		uniq = append(uniq, e)
	}
	return uniq
}

func sortExports(exports []exportDecl) {
	kindOrder := map[string]int{
		"const":  1,
		"var":    2,
		"type":   3,
		"func":   4,
		"method": 5,
	}
	sort.Slice(exports, func(i, j int) bool {
		ki, kj := kindOrder[exports[i].Kind], kindOrder[exports[j].Kind]
		if ki != kj {
			return ki < kj
		}
		if exports[i].Name != exports[j].Name {
			return exports[i].Name < exports[j].Name
		}
		return exports[i].Decl < exports[j].Decl
	})
}

func normalizeFileForSnapshot(file *ast.File) {
	ast.Inspect(file, func(node ast.Node) bool {
		ft, ok := node.(*ast.FuncType)
		if !ok {
			return true
		}
		// IMPORTANT: do not touch ft.TypeParams. Type parameter names may be referenced in
		// parameter/result types and cannot be safely anonymized.
		ft.Params = normalizeFieldList(ft.Params)
		ft.Results = normalizeFieldList(ft.Results)
		return true
	})
}

func normalizeFieldList(list *ast.FieldList) *ast.FieldList {
	if list == nil || len(list.List) == 0 {
		return list
	}
	out := &ast.FieldList{Opening: list.Opening, Closing: list.Closing}
	for _, field := range list.List {
		n := 1
		if len(field.Names) > 0 {
			n = len(field.Names)
		}
		for i := 0; i < n; i++ {
			out.List = append(out.List, &ast.Field{Type: field.Type})
		}
	}
	return out
}

func funcDeclKind(d *ast.FuncDecl) string {
	if d.Recv == nil {
		return "func"
	}
	return "method"
}

func funcDeclName(d *ast.FuncDecl) string {
	if d.Recv == nil {
		return d.Name.Name
	}
	recv := receiverTypeString(d.Recv)
	return recv + "." + d.Name.Name
}

func receiverTypeString(recv *ast.FieldList) string {
	if recv == nil || len(recv.List) == 0 {
		return unknownReceiverType
	}
	var buf bytes.Buffer
	// Omit receiver names for stability.
	f := &ast.Field{Type: recv.List[0].Type}
	if err := format.Node(&buf, token.NewFileSet(), f.Type); err != nil {
		return unknownReceiverType
	}
	return strings.TrimSpace(buf.String())
}

func formatFuncDecl(fset *token.FileSet, d *ast.FuncDecl) string {
	clone := *d
	clone.Body = nil
	if clone.Recv != nil {
		clone.Recv = &ast.FieldList{Opening: clone.Recv.Opening, Closing: clone.Recv.Closing}
		for _, field := range d.Recv.List {
			clone.Recv.List = append(clone.Recv.List, &ast.Field{Type: field.Type})
		}
	}

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, &clone); err != nil {
		return fmt.Sprintf("/* format error: %v */", err)
	}
	return strings.TrimSpace(buf.String())
}

func formatTypeSpec(fset *token.FileSet, ts *ast.TypeSpec) string {
	clone := *ts
	clone.Doc = nil
	clone.Comment = nil
	gen := &ast.GenDecl{Tok: token.TYPE, Specs: []ast.Spec{&clone}}

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, gen); err != nil {
		return fmt.Sprintf("/* format error: %v */", err)
	}
	return strings.TrimSpace(buf.String())
}

func formatValueSpecExports(fset *token.FileSet, tok token.Token, vs *ast.ValueSpec) []exportDecl {
	if len(vs.Names) == 0 {
		return nil
	}

	exported := make([]int, 0, len(vs.Names))
	for i, name := range vs.Names {
		if ast.IsExported(name.Name) {
			exported = append(exported, i)
		}
	}
	if len(exported) == 0 {
		return nil
	}

	kind := "var"
	if tok == token.CONST {
		kind = "const"
	}

	if len(vs.Names) == 1 {
		return []exportDecl{
			{
				Kind: kind,
				Name: vs.Names[0].Name,
				Decl: formatValueSpec(fset, tok, vs),
			},
		}
	}

	if len(vs.Values) == 0 || len(vs.Values) == len(vs.Names) {
		out := make([]exportDecl, 0, len(exported))
		for _, idx := range exported {
			s := &ast.ValueSpec{
				Names: []*ast.Ident{{Name: vs.Names[idx].Name}},
				Type:  vs.Type,
			}
			if len(vs.Values) == len(vs.Names) {
				s.Values = []ast.Expr{vs.Values[idx]}
			}
			out = append(out, exportDecl{
				Kind: kind,
				Name: vs.Names[idx].Name,
				Decl: formatValueSpec(fset, tok, s),
			})
		}
		return out
	}

	// Fallback: keep the combined spec. This can include unexported names in rare
	// multi-value assignment cases, but preserves a faithful signature.
	return []exportDecl{
		{
			Kind: kind,
			Name: vs.Names[exported[0]].Name,
			Decl: formatValueSpec(fset, tok, vs),
		},
	}
}

func formatValueSpec(fset *token.FileSet, tok token.Token, vs *ast.ValueSpec) string {
	clone := *vs
	clone.Doc = nil
	clone.Comment = nil
	gen := &ast.GenDecl{Tok: tok, Specs: []ast.Spec{&clone}}
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, gen); err != nil {
		return fmt.Sprintf("/* format error: %v */", err)
	}
	return strings.TrimSpace(buf.String())
}
