#!/usr/bin/env python3

from __future__ import annotations

import argparse
import ast
import hashlib
import sys
from pathlib import Path


CURATED_PUBLIC_PACKAGES = {
    "apptheory",
    "apptheory.limited",
}


def sha256_hex(data: bytes) -> str:
    h = hashlib.sha256()
    h.update(data)
    return h.hexdigest()


def extract_all_names(module: ast.Module) -> list[str]:
    assignments: list[ast.Assign] = [
        n
        for n in module.body
        if isinstance(n, ast.Assign)
        and len(n.targets) == 1
        and isinstance(n.targets[0], ast.Name)
        and n.targets[0].id == "__all__"
    ]
    if not assignments:
        raise ValueError("missing __all__ assignment")

    value = assignments[-1].value
    if not isinstance(value, (ast.List, ast.Tuple)):
        raise ValueError("__all__ must be a list or tuple literal")

    names: list[str] = []
    for elt in value.elts:
        if isinstance(elt, ast.Constant) and isinstance(elt.value, str):
            names.append(elt.value)
            continue
        if isinstance(elt, ast.Str):
            names.append(elt.s)
            continue
        raise ValueError(f"__all__ must contain only strings; found {type(elt).__name__}")

    names.sort()
    return names


def module_name_from_file(src: Path) -> str:
    parts = src.as_posix().split("/")
    if "py" in parts:
        py_idx = parts.index("py")
        if py_idx + 1 < len(parts) and parts[py_idx + 1] == "src":
            parts = parts[py_idx + 2 :]
    if parts and parts[-1] == "__init__.py":
        parts = parts[:-1]
    elif parts:
        parts[-1] = parts[-1].removesuffix(".py")
    return ".".join(p for p in parts if p)


def curated_sources(root: Path) -> list[Path]:
    candidates = [root / "__init__.py"]
    candidates.extend(p / "__init__.py" for p in root.iterdir() if p.is_dir())

    by_module: dict[str, Path] = {}
    for src in candidates:
        if not src.is_file():
            continue
        module = module_name_from_file(src)
        if module in CURATED_PUBLIC_PACKAGES:
            by_module[module] = src

    missing = sorted(CURATED_PUBLIC_PACKAGES - set(by_module))
    if missing:
        missing_str = ", ".join(missing)
        raise ValueError(f"curated packages missing __init__.py: {missing_str}")

    return [by_module[m] for m in sorted(by_module)]


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--mode",
        choices=("files", "curated"),
        default="files",
        help="Snapshot one or more files, or a curated allowlist of apptheory subpackages.",
    )
    parser.add_argument(
        "--root",
        default="py/src/apptheory",
        help="Root apptheory package dir (used for --mode curated).",
    )
    parser.add_argument("sources", nargs="*", help="Python module file(s) to snapshot.")
    args = parser.parse_args()

    if args.mode == "curated":
        sources = curated_sources(Path(args.root))
    else:
        sources = [Path(p) for p in (args.sources or ["py/src/apptheory/__init__.py"])]

    snapshots: list[tuple[str, Path, str, list[str]]] = []
    for src in sources:
        data = src.read_bytes()
        text = data.decode("utf-8")
        module = ast.parse(text, filename=src.as_posix())
        names = extract_all_names(module)
        snapshots.append((module_name_from_file(src), src, sha256_hex(data), names))

    snapshots.sort(key=lambda s: s[0])

    sys.stdout.write("# AppTheory Python public API snapshot\n")
    sys.stdout.write(f"# Mode: {args.mode}\n")
    for module_name, src, sha, _names in snapshots:
        sys.stdout.write(f"# Source[{module_name}]: {src.as_posix()}\n")
        sys.stdout.write(f"# SHA256[{module_name}]: {sha}\n")
    sys.stdout.write("# Generated by: scripts/update-api-snapshots.sh\n")
    sys.stdout.write("# DO NOT EDIT MANUALLY\n\n")

    for module_name, _src, _sha, names in snapshots:
        sys.stdout.write(f"[{module_name}.__all__]\n")
        for name in names:
            sys.stdout.write(f"{name}\n")
        sys.stdout.write("\n")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
