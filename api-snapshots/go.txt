# AppTheory Go public API snapshot
# Scope: ./runtime/... ./pkg/... ./testkit/...
# Go version: go1.26.0
# Generated by: scripts/update-api-snapshots.sh
# DO NOT EDIT MANUALLY

## github.com/theory-cloud/apptheory/pkg/limited

const ErrorTypeInternal ErrorType = "internal_error"

const ErrorTypeInvalidInput ErrorType = "invalid_input"

const ErrorTypeRateLimit ErrorType = "rate_limit_exceeded"

type AtomicRateLimiter interface {
	RateLimiter

	CheckAndIncrement(context.Context, RateLimitKey) (*LimitDecision, error)
}

type Clock interface {
	Now() time.Time
}

type Config struct {
	DefaultRequestsPerHour   int
	DefaultRequestsPerMinute int
	DefaultBurstCapacity     int

	EnableBurstCapacity bool
	EnableSoftLimits    bool
	FailOpen            bool

	TableName      string
	ConsistentRead bool
	TTLHours       int

	IdentifierLimits map[string]Limit
	ResourceLimits   map[string]Limit
}

type DynamoRateLimiter struct {
	db       tablecore.DB
	config   *Config
	strategy RateLimitStrategy
	clock    Clock
}

type Error struct {
	Type    ErrorType
	Message string
	Cause   error
}

type ErrorType string

type FixedWindowStrategy struct {
	WindowSize  time.Duration
	MaxRequests int

	IdentifierLimits map[string]int
	ResourceLimits   map[string]int
}

type Limit struct {
	RequestsPerHour   int
	RequestsPerMinute int
	BurstCapacity     int
	CustomWindows     map[string]WindowLimit
}

type LimitDecision struct {
	Allowed      bool
	CurrentCount int
	Limit        int
	ResetsAt     time.Time
	RetryAfter   *time.Duration
}

type MultiWindowStrategy struct {
	Windows          []WindowConfig
	IdentifierLimits map[string][]WindowConfig
	ResourceLimits   map[string][]WindowConfig
}

type RateLimitEntry struct {
	PK string `theorydb:"pk" json:"pk"`
	SK string `theorydb:"sk" json:"sk"`

	Identifier string `json:"identifier"`
	Resource   string `json:"resource"`
	Operation  string `json:"operation"`

	WindowStart int64  `json:"window_start"`
	WindowType  string `json:"window_type"`
	WindowID    string `json:"window_id"`

	Count int64 `json:"count"`

	TTL int64 `theorydb:"ttl" json:"ttl"`

	CreatedAt time.Time         `theorydb:"created_at" json:"created_at"`
	UpdatedAt time.Time         `theorydb:"updated_at" json:"updated_at"`
	Metadata  map[string]string `json:"metadata,omitempty"`
}

type RateLimitKey struct {
	Identifier string
	Resource   string
	Operation  string
	Metadata   map[string]string
}

type RateLimitStrategy interface {
	CalculateWindows(time.Time) []TimeWindow
	GetLimit(RateLimitKey) int
	ShouldAllow(map[string]int, int) bool
}

type RateLimitWindow struct {
	WindowType string
	Start      time.Time
	End        time.Time
}

type RateLimiter interface {
	CheckLimit(context.Context, RateLimitKey) (*LimitDecision, error)

	RecordRequest(context.Context, RateLimitKey) error

	GetUsage(context.Context, RateLimitKey) (*UsageStats, error)
}

type RealClock struct{}

type SlidingWindowStrategy struct {
	WindowSize  time.Duration
	MaxRequests int
	Granularity time.Duration

	IdentifierLimits map[string]int
	ResourceLimits   map[string]int
}

type TimeWindow struct {
	Start time.Time
	End   time.Time
	Key   string
}

type UsageStats struct {
	Identifier    string
	Resource      string
	CurrentHour   UsageWindow
	CurrentMinute UsageWindow
	DailyTotal    int
	CustomWindows map[string]UsageWindow
}

type UsageWindow struct {
	Count       int
	Limit       int
	WindowStart time.Time
	WindowEnd   time.Time
}

type WindowConfig struct {
	Duration    time.Duration
	MaxRequests int
}

type WindowLimit struct {
	Duration time.Duration
	Requests int
}

func DefaultConfig() *Config

func GetDayWindow(time.Time) RateLimitWindow

func GetFixedWindow(time.Time, time.Duration) RateLimitWindow

func GetHourWindow(time.Time) RateLimitWindow

func GetMinuteWindow(time.Time) RateLimitWindow

func NewDynamoRateLimiter(tablecore.DB, *Config, RateLimitStrategy) *DynamoRateLimiter

func NewError(ErrorType, string) *Error

func NewFixedWindowStrategy(time.Duration, int) *FixedWindowStrategy

func NewMultiWindowStrategy([]WindowConfig) *MultiWindowStrategy

func NewSlidingWindowStrategy(time.Duration, int, time.Duration) *SlidingWindowStrategy

func WrapError(error, ErrorType, string) *Error

func (*DynamoRateLimiter) CheckAndIncrement(context.Context, RateLimitKey) (*LimitDecision, error)

func (*DynamoRateLimiter) CheckLimit(context.Context, RateLimitKey) (*LimitDecision, error)

func (*DynamoRateLimiter) GetUsage(context.Context, RateLimitKey) (*UsageStats, error)

func (*DynamoRateLimiter) RecordRequest(context.Context, RateLimitKey) error

func (*DynamoRateLimiter) SetClock(Clock)

func (*DynamoRateLimiter) String() string

func (*Error) Error() string

func (*Error) Unwrap() error

func (*FixedWindowStrategy) CalculateWindows(time.Time) []TimeWindow

func (*FixedWindowStrategy) GetLimit(RateLimitKey) int

func (*FixedWindowStrategy) SetIdentifierLimit(string, int)

func (*FixedWindowStrategy) SetResourceLimit(string, int)

func (*FixedWindowStrategy) ShouldAllow(map[string]int, int) bool

func (*MultiWindowStrategy) CalculateWindows(time.Time) []TimeWindow

func (*MultiWindowStrategy) GetLimit(RateLimitKey) int

func (*MultiWindowStrategy) ShouldAllow(map[string]int, int) bool

func (*RateLimitEntry) GetCompositeID() string

func (*RateLimitEntry) SetKeys()

func (*RateLimitEntry) SetTTL(time.Duration, time.Duration)

func (*SlidingWindowStrategy) CalculateWindows(time.Time) []TimeWindow

func (*SlidingWindowStrategy) GetLimit(RateLimitKey) int

func (*SlidingWindowStrategy) SetIdentifierLimit(string, int)

func (*SlidingWindowStrategy) SetResourceLimit(string, int)

func (*SlidingWindowStrategy) ShouldAllow(map[string]int, int) bool

func (RateLimitEntry) TableName() string

func (RealClock) Now() time.Time

## github.com/theory-cloud/apptheory/pkg/limited/middleware

const IdentifierKey contextKey = "rate_limit_identifier"

type Options struct {
	Limiter limited.RateLimiter

	ExtractIdentifier func(*http.Request) string
	ExtractResource   func(*http.Request) string
	ExtractOperation  func(*http.Request) string

	ErrorHandler func(http.ResponseWriter, *http.Request, *limited.LimitDecision)
	OnSuccess    func(*http.Request, *limited.LimitDecision)
	OnRateLimit  func(*http.Request, *limited.LimitDecision)

	SkipRequest func(*http.Request) bool
}

func Middleware(Options) func(http.HandlerFunc) http.HandlerFunc

func WithIdentifier(*http.Request, string) *http.Request

## github.com/theory-cloud/apptheory/pkg/logger

var PaymentXMLPatterns = sanitization.PaymentXMLPatterns

var RapidConnectXMLPatterns = sanitization.RapidConnectXMLPatterns

func Logger() observability.StructuredLogger

func SanitizeFieldValue(string, any) any

func SanitizeJSON([]byte) string

func SanitizeLogString(string) string

func SanitizeXML(string, []sanitization.XMLSanitizationPattern) string

func SetLogger(observability.StructuredLogger)

## github.com/theory-cloud/apptheory/pkg/naming

func BaseName(string, string, string) string

func NormalizeStage(string) string

func ResourceName(string, string, string, string) string

## github.com/theory-cloud/apptheory/pkg/observability

type ErrorNotifier interface {
	Notify(context.Context, LogEntry) error
}

type LogEntry struct {
	Timestamp time.Time      `json:"timestamp"`
	Level     string         `json:"level"`
	Message   string         `json:"message"`
	Fields    map[string]any `json:"fields,omitempty"`

	RequestID string `json:"request_id,omitempty"`
	TenantID  string `json:"tenant_id,omitempty"`
	UserID    string `json:"user_id,omitempty"`
	TraceID   string `json:"trace_id,omitempty"`
	SpanID    string `json:"span_id,omitempty"`
}

type LoggerConfig struct {
	Format       string        `json:"format"`
	Level        string        `json:"level"`
	RetryDelay   time.Duration `json:"retry_delay"`
	BatchSize    int           `json:"batch_size"`
	BufferSize   int           `json:"buffer_size"`
	MaxRetries   int           `json:"max_retries"`
	EnableStack  bool          `json:"enable_stack"`
	EnableCaller bool          `json:"enable_caller"`
}

type LoggerFactory interface {
	CreateConsoleLogger(LoggerConfig) (StructuredLogger, error)
	CreateTestLogger() StructuredLogger
	CreateNoOpLogger() StructuredLogger
}

type LoggerStats struct {
	LastFlush      time.Time     `json:"last_flush"`
	LastError      string        `json:"last_error,omitempty"`
	EntriesLogged  int64         `json:"entries_logged"`
	EntriesDropped int64         `json:"entries_dropped"`
	FlushCount     int64         `json:"flush_count"`
	ErrorCount     int64         `json:"error_count"`
	AverageFlush   time.Duration `json:"average_flush_time"`
}

type SanitizerFunc func(string, any) any

type StructuredLogger interface {
	Debug(string, ...map[string]any)
	Info(string, ...map[string]any)
	Warn(string, ...map[string]any)
	Error(string, ...map[string]any)

	WithField(string, any) StructuredLogger
	WithFields(map[string]any) StructuredLogger

	WithRequestID(string) StructuredLogger
	WithTenantID(string) StructuredLogger
	WithUserID(string) StructuredLogger
	WithTraceID(string) StructuredLogger
	WithSpanID(string) StructuredLogger

	Flush(context.Context) error
	Close() error
	IsHealthy() bool
	GetStats() LoggerStats
}

type TestLogger struct {
	core *testLoggerCore

	fields   map[string]any
	sanitize SanitizerFunc

	requestID string
	tenantID  string
	userID    string
	traceID   string
	spanID    string

	closed atomic.Bool
}

func HooksFromLogger(StructuredLogger) apptheory.ObservabilityHooks

func NewNoOpLogger() StructuredLogger

func NewTestLogger() *TestLogger

func (*TestLogger) Close() error

func (*TestLogger) Debug(string, ...map[string]any)

func (*TestLogger) Entries() []LogEntry

func (*TestLogger) Error(string, ...map[string]any)

func (*TestLogger) Flush(context.Context) error

func (*TestLogger) GetStats() LoggerStats

func (*TestLogger) Info(string, ...map[string]any)

func (*TestLogger) IsHealthy() bool

func (*TestLogger) Warn(string, ...map[string]any)

func (*TestLogger) WithField(string, any) StructuredLogger

func (*TestLogger) WithFields(map[string]any) StructuredLogger

func (*TestLogger) WithRequestID(string) StructuredLogger

func (*TestLogger) WithSpanID(string) StructuredLogger

func (*TestLogger) WithTenantID(string) StructuredLogger

func (*TestLogger) WithTraceID(string) StructuredLogger

func (*TestLogger) WithUserID(string) StructuredLogger

func (*noopLogger) Close() error

func (*noopLogger) Debug(string, ...map[string]any)

func (*noopLogger) Error(string, ...map[string]any)

func (*noopLogger) Flush(context.Context) error

func (*noopLogger) GetStats() LoggerStats

func (*noopLogger) Info(string, ...map[string]any)

func (*noopLogger) IsHealthy() bool

func (*noopLogger) Warn(string, ...map[string]any)

func (*noopLogger) WithField(string, any) StructuredLogger

func (*noopLogger) WithFields(map[string]any) StructuredLogger

func (*noopLogger) WithRequestID(string) StructuredLogger

func (*noopLogger) WithSpanID(string) StructuredLogger

func (*noopLogger) WithTenantID(string) StructuredLogger

func (*noopLogger) WithTraceID(string) StructuredLogger

func (*noopLogger) WithUserID(string) StructuredLogger

## github.com/theory-cloud/apptheory/pkg/observability/zap

type EnvironmentErrorNotificationsOptions struct {
	TopicARNEnvVars []string
	SubjectEnvVars  []string
}

type Factory struct {
	options []Option
}

type Logger struct {
	core *zapCore
	log  *ubzap.Logger

	fields map[string]any

	requestID string
	tenantID  string
	userID    string
	traceID   string
	spanID    string
}

type Option func(*loggerOptions)

type SNSNotifierOptions struct {
	Subject string
}

func DefaultEnvironmentErrorNotifications() EnvironmentErrorNotificationsOptions

func NewSNSNotifier(snsAPI, string, SNSNotifierOptions) observability.ErrorNotifier

func NewZapLogger(observability.LoggerConfig, ...Option) (observability.StructuredLogger, error)

func NewZapLoggerFactory(...Option) *Factory

func WithEnvironmentErrorNotifications(context.Context, EnvironmentErrorNotificationsOptions) Option

func WithErrorNotifier(observability.ErrorNotifier) Option

func WithSanitizer(observability.SanitizerFunc) Option

func WithZapLogger(*ubzap.Logger) Option

func (*Factory) CreateConsoleLogger(observability.LoggerConfig) (observability.StructuredLogger, error)

func (*Factory) CreateNoOpLogger() observability.StructuredLogger

func (*Factory) CreateTestLogger() observability.StructuredLogger

func (*Logger) Close() error

func (*Logger) Debug(string, ...map[string]any)

func (*Logger) Error(string, ...map[string]any)

func (*Logger) Flush(context.Context) error

func (*Logger) GetStats() observability.LoggerStats

func (*Logger) Info(string, ...map[string]any)

func (*Logger) IsHealthy() bool

func (*Logger) Warn(string, ...map[string]any)

func (*Logger) WithField(string, any) observability.StructuredLogger

func (*Logger) WithFields(map[string]any) observability.StructuredLogger

func (*Logger) WithRequestID(string) observability.StructuredLogger

func (*Logger) WithSpanID(string) observability.StructuredLogger

func (*Logger) WithTenantID(string) observability.StructuredLogger

func (*Logger) WithTraceID(string) observability.StructuredLogger

func (*Logger) WithUserID(string) observability.StructuredLogger

func (*snsNotifier) Notify(context.Context, observability.LogEntry) error

## github.com/theory-cloud/apptheory/pkg/sanitization

const FullyRedact SanitizationType = iota

const PartialMask

var AllowedFields = map[string]bool{
	"card_bin":   true,
	"card_brand": true,
	"card_type":  true,
}

var PaymentXMLPatterns = []XMLSanitizationPattern{
	{
		Name:        "AcctNum",
		Pattern:     regexp.MustCompile(`(?i)(<AcctNum>[^<]*</AcctNum>|&lt;AcctNum&gt;[^&]*&lt;/AcctNum&gt;)`),
		MaskingFunc: MaskCardNumber,
	},
	{
		Name:        "CardNum",
		Pattern:     regexp.MustCompile(`(?i)(<CardNum>[^<]*</CardNum>|&lt;CardNum&gt;[^&]*&lt;/CardNum&gt;)`),
		MaskingFunc: MaskCardNumber,
	},
	{
		Name:        "CardNumber",
		Pattern:     regexp.MustCompile(`(?i)(<CardNumber>[^<]*</CardNumber>|&lt;CardNumber&gt;[^&]*&lt;/CardNumber&gt;)`),
		MaskingFunc: MaskCardNumber,
	},
	{
		Name:        "TrackData",
		Pattern:     regexp.MustCompile(`(?i)(<TrackData>[^<]*</TrackData>|&lt;TrackData&gt;[^&]*&lt;/TrackData&gt;)`),
		MaskingFunc: MaskCompletelyFunc(redactedValue),
	},
	{
		Name:        "CVV",
		Pattern:     regexp.MustCompile(`(?i)(<CVV>[^<]*</CVV>|&lt;CVV&gt;[^&]*&lt;/CVV&gt;)`),
		MaskingFunc: MaskCompletelyFunc(redactedValue),
	},
	{
		Name:        "CVV2",
		Pattern:     regexp.MustCompile(`(?i)(<CVV2>[^<]*</CVV2>|&lt;CVV2&gt;[^&]*&lt;/CVV2&gt;)`),
		MaskingFunc: MaskCompletelyFunc(redactedValue),
	},
	{
		Name:        "CVC",
		Pattern:     regexp.MustCompile(`(?i)(<CVC>[^<]*</CVC>|&lt;CVC&gt;[^&]*&lt;/CVC&gt;)`),
		MaskingFunc: MaskCompletelyFunc(redactedValue),
	},
	{
		Name:        "ExpDate",
		Pattern:     regexp.MustCompile(`(?i)(<ExpDate>[^<]*</ExpDate>|&lt;ExpDate&gt;[^&]*&lt;/ExpDate&gt;)`),
		MaskingFunc: MaskCompletelyFunc(redactedValue),
	},
	{
		Name:        "ExpiryDate",
		Pattern:     regexp.MustCompile(`(?i)(<ExpiryDate>[^<]*</ExpiryDate>|&lt;ExpiryDate&gt;[^&]*&lt;/ExpiryDate&gt;)`),
		MaskingFunc: MaskCompletelyFunc(redactedValue),
	},
	{
		Name:        "Password",
		Pattern:     regexp.MustCompile(`(?i)(<Password>[^<]*</Password>|&lt;Password&gt;[^&]*&lt;/Password&gt;)`),
		MaskingFunc: MaskCompletelyFunc(redactedValue),
	},
	{
		Name:        "TransArmorToken",
		Pattern:     regexp.MustCompile(`(?i)(<TransArmorToken>[^<]*</TransArmorToken>|&lt;TransArmorToken&gt;[^&]*&lt;/TransArmorToken&gt;)`),
		MaskingFunc: MaskTokenLastFour,
	},
}

var RapidConnectXMLPatterns = PaymentXMLPatterns

var SensitiveFields = map[string]SanitizationType{
	"cvv":           FullyRedact,
	"security_code": FullyRedact,
	"cvv2":          FullyRedact,
	"cvc":           FullyRedact,
	"cvc2":          FullyRedact,

	"cardholder":      FullyRedact,
	"cardholder_name": FullyRedact,

	"card_number": PartialMask,
	"number":      PartialMask,

	"account_number": PartialMask,
	"ssn":            PartialMask,
	"tin":            PartialMask,
	"tax_id":         PartialMask,
	"ein":            PartialMask,

	"password":    FullyRedact,
	"secret":      FullyRedact,
	"private_key": FullyRedact,
	"secret_key":  FullyRedact,

	"api_token":            FullyRedact,
	"api_key_id":           PartialMask,
	"authorization":        FullyRedact,
	"authorization_id":     FullyRedact,
	"authorization_header": FullyRedact,
}

type SanitizationType int

type XMLSanitizationPattern struct {
	Pattern     *regexp.Regexp
	MaskingFunc func(string) string
	Name        string
}

func MaskCardNumber(string) string

func MaskCompletelyFunc(string) func(string) string

func MaskFirstLast(string, int, int) string

func MaskFirstLast4(string) string

func MaskTokenLastFour(string) string

func SanitizeFieldValue(string, any) any

func SanitizeJSON([]byte) string

func SanitizeLogString(string) string

func SanitizeXML(string, []XMLSanitizationPattern) string

## github.com/theory-cloud/apptheory/pkg/services

type DynamoDBEventBus struct {
	handlers map[string][]EventHandler
	db       tablecore.DB
	config   EventBusConfig
}

type Event struct {
	_ struct{} `theorydb:"naming:snake_case"`

	PublishedAt time.Time `json:"published_at" theorydb:"index:tenant-timestamp-index,sk"`
	CreatedAt   time.Time `json:"created_at" theorydb:"created_at"`
	ExpiresAt   time.Time `json:"expires_at,omitempty" theorydb:"omitempty"`

	ID            string `json:"id" theorydb:"index:event-id-index,pk"`
	EventType     string `json:"event_type"`
	TenantID      string `json:"tenant_id" theorydb:"index:tenant-timestamp-index,pk"`
	SourceID      string `json:"source_id"`
	PartitionKey  string `json:"partition_key" theorydb:"pk,attr:pk"`
	SortKey       string `json:"sort_key" theorydb:"sk,attr:sk"`
	CorrelationID string `json:"correlation_id,omitempty" theorydb:"omitempty"`

	Payload  json.RawMessage   `json:"payload"`
	Metadata map[string]string `json:"metadata,omitempty" theorydb:"omitempty"`
	Tags     []string          `json:"tags,omitempty" theorydb:"set,omitempty"`

	TTL int64 `json:"-" theorydb:"ttl,omitempty"`

	Version    int `json:"version"`
	RetryCount int `json:"retry_count"`
}

type EventBus interface {
	Publish(context.Context, *Event) (string, error)

	Query(context.Context, *EventQuery) ([]*Event, error)

	Subscribe(context.Context, string, EventHandler) error

	GetEvent(context.Context, string) (*Event, error)

	DeleteEvent(context.Context, string) error
}

type EventBusConfig struct {
	TableName        string
	MetricsNamespace string
	TTL              time.Duration
	RetryBaseDelay   time.Duration
	RetryAttempts    int
	MaxBatchSize     int
	EnableMetrics    bool
	EmitMetric       func(MetricRecord)
}

type EventHandler func(context.Context, *Event) error

type EventQuery struct {
	LastEvaluatedKey map[string]any
	NextKey          map[string]any

	StartTime *time.Time
	EndTime   *time.Time

	TenantID  string
	EventType string
	Tags      []string
	Limit     int
}

type MemoryEventBus struct {
	events   map[string]*Event
	handlers map[string][]EventHandler
	mu       sync.RWMutex
}

type MetricRecord struct {
	Namespace string
	Name      string
	Value     float64
	Tags      map[string]string
}

func DefaultEventBusConfig() EventBusConfig

func NewDynamoDBEventBus(tablecore.DB, EventBusConfig) *DynamoDBEventBus

func NewEvent(string, string, string, any) (*Event, error)

func NewMemoryEventBus() *MemoryEventBus

func (*DynamoDBEventBus) DeleteEvent(context.Context, string) error

func (*DynamoDBEventBus) GetEvent(context.Context, string) (*Event, error)

func (*DynamoDBEventBus) Publish(context.Context, *Event) (string, error)

func (*DynamoDBEventBus) Query(context.Context, *EventQuery) ([]*Event, error)

func (*DynamoDBEventBus) Subscribe(context.Context, string, EventHandler) error

func (*Event) TableName() string

func (*Event) UnmarshalPayload(any) error

func (*Event) WithCorrelationID(string) *Event

func (*Event) WithMetadata(string, string) *Event

func (*Event) WithTTL(time.Duration) *Event

func (*Event) WithTags(...string) *Event

func (*MemoryEventBus) DeleteEvent(context.Context, string) error

func (*MemoryEventBus) GetEvent(context.Context, string) (*Event, error)

func (*MemoryEventBus) Publish(context.Context, *Event) (string, error)

func (*MemoryEventBus) Query(context.Context, *EventQuery) ([]*Event, error)

func (*MemoryEventBus) Subscribe(context.Context, string, EventHandler) error

## github.com/theory-cloud/apptheory/pkg/streamer

type Client interface {
	PostToConnection(context.Context, string, []byte) error
	GetConnection(context.Context, string) (Connection, error)
	DeleteConnection(context.Context, string) error
}

type Connection struct {
	ConnectedAt   time.Time
	LastActiveAt  time.Time
	IdentityIP    string
	IdentityAgent string
}

type Option func(*clientOptions)

func NewClient(context.Context, string, ...Option) (Client, error)

func WithAPI(apiGatewayManagementAPI) Option

func WithAWSConfig(aws.Config) Option

func (*client) DeleteConnection(context.Context, string) error

func (*client) GetConnection(context.Context, string) (Connection, error)

func (*client) PostToConnection(context.Context, string, []byte) error

## github.com/theory-cloud/apptheory/runtime

const RateLimitDecisionKey = "rate_limit_decision"

const TierP0 Tier = "p0"

const TierP1 Tier = "p1"

const TierP2 Tier = "p2"

type App struct {
	router           *router
	clock            Clock
	ids              IDGenerator
	tier             Tier
	limits           Limits
	cors             CORSConfig
	auth             AuthHook
	obs              ObservabilityHooks
	policy           PolicyHook
	middlewares      []Middleware
	eventMiddlewares []EventMiddleware

	sqsRoutes         []sqsRoute
	kinesisRoutes     []kinesisRoute
	snsRoutes         []snsRoute
	eventBridgeRoutes []eventBridgeRoute
	dynamoDBRoutes    []dynamoDBRoute

	webSocketEnabled       bool
	webSocketRoutes        []webSocketRoute
	webSocketClientFactory WebSocketClientFactory
}

type AppError struct {
	Code    string
	Message string
}

type AppTheoryError struct {
	Code       string
	Message    string
	StatusCode int
	Details    map[string]any
	RequestID  string
	TraceID    string
	Timestamp  time.Time
	StackTrace string
	Cause      error
}

type AuthHook func(*Context) (string, error)

type BodyStream <-chan StreamChunk

type CORSConfig struct {
	AllowedOrigins   []string
	AllowCredentials bool
	AllowHeaders     []string
}

type Clock interface {
	Now() time.Time
}

type Context struct {
	ctx     context.Context
	Request Request
	Params  map[string]string
	clock   Clock
	ids     IDGenerator

	RequestID       string
	TenantID        string
	AuthIdentity    string
	RemainingMS     int
	MiddlewareTrace []string

	ws *WebSocketContext

	values map[string]any
}

type DynamoDBStreamHandler func(*EventContext, events.DynamoDBEventRecord) error

type EventBridgeHandler func(*EventContext, events.EventBridgeEvent) (any, error)

type EventBridgeSelector struct {
	RuleName   string
	Source     string
	DetailType string
}

type EventContext struct {
	ctx context.Context

	clock Clock
	ids   IDGenerator

	RequestID   string
	RemainingMS int

	values map[string]any
}

type EventHandler func(*EventContext, any) (any, error)

type EventMiddleware func(EventHandler) EventHandler

type Handler func(*Context) (*Response, error)

type IDGenerator interface {
	NewID() string
}

type IdGenerator = IDGenerator

type KinesisHandler func(*EventContext, events.KinesisEventRecord) error

type Limits struct {
	MaxRequestBytes  int
	MaxResponseBytes int
}

type LogRecord struct {
	Level     string
	Event     string
	RequestID string
	TenantID  string
	Method    string
	Path      string
	Status    int
	ErrorCode string
}

type MetricRecord struct {
	Name  string
	Value int
	Tags  map[string]string
}

type Middleware func(Handler) Handler

type ObservabilityHooks struct {
	Log    func(LogRecord)
	Metric func(MetricRecord)
	Span   func(SpanRecord)
}

type Option func(*App)

type PolicyDecision struct {
	Code    string
	Message string
	Headers map[string][]string
}

type PolicyHook func(*Context) (*PolicyDecision, error)

type RandomIDGenerator struct{}

type RandomIdGenerator = RandomIDGenerator

type RateLimitConfig struct {
	Limiter limited.RateLimiter

	FailClosed bool

	ExtractIdentifier func(*Context) string
	ExtractResource   func(*Context) string
	ExtractOperation  func(*Context) string

	OnError     func(*Context, error)
	OnSuccess   func(*Context, *limited.LimitDecision)
	OnRateLimit func(*Context, *limited.LimitDecision)
}

type RealClock struct{}

type Request struct {
	Method string
	Path   string
	Query  map[string][]string

	Headers  map[string][]string
	Cookies  map[string]string
	Body     []byte
	IsBase64 bool
}

type Response struct {
	Status int

	Headers map[string][]string

	Cookies    []string
	Body       []byte
	BodyReader io.Reader
	BodyStream BodyStream
	IsBase64   bool
}

type RouteOption func(*routeOptions)

type SNSHandler func(*EventContext, events.SNSEventRecord) (any, error)

type SQSHandler func(*EventContext, events.SQSMessage) error

type SSEEvent struct {
	ID    string
	Event string
	Data  any
}

type SpanRecord struct {
	Name       string
	Attributes map[string]string
}

type StreamChunk struct {
	Bytes []byte
	Err   error
}

type Tier string

type TimeoutConfig struct {
	DefaultTimeout    time.Duration
	OperationTimeouts map[string]time.Duration
	TenantTimeouts    map[string]time.Duration
	TimeoutMessage    string
}

type WebSocketClientFactory func(context.Context, string) (streamer.Client, error)

type WebSocketContext struct {
	ctx context.Context

	clock Clock
	ids   IDGenerator

	RequestID   string
	RemainingMS int

	ConnectionID       string
	RouteKey           string
	DomainName         string
	Stage              string
	EventType          string
	ManagementEndpoint string

	Body []byte

	clientFactory WebSocketClientFactory
	client        streamer.Client
	clientErr     error
}

type WebSocketHandler func(*Context) (*Response, error)

func AppTheoryErrorFromAppError(*AppError) *AppTheoryError

func AsAppTheoryError(error) (*AppTheoryError, bool)

func Binary(int, []byte, string) *Response

func CacheControlISR(int, int) string

func CacheControlSSG() string

func CacheControlSSR() string

func CaptureBodyStream(context.Context, BodyStream) ([][]byte, []byte, error)

func ClientIP(map[string][]string) string

func ETag([]byte) string

func EventBridgePattern(string, string) EventBridgeSelector

func EventBridgeRule(string) EventBridgeSelector

func HTML(int, any) *Response

func HTMLStream(int, BodyStream) *Response

func IsLambda() bool

func JSON(int, any) (*Response, error)

func JSONHandler[Req, Resp any](func(*Context, Req) (Resp, error)) Handler

func JSONHandlerContext[Req, Resp any](func(context.Context, Req) (Resp, error)) Handler

func MatchesIfNoneMatch(map[string][]string, string) bool

func MustJSON(int, any) *Response

func MustSSEResponse(int, ...SSEEvent) *Response

func New(...Option) *App

func NewAppTheoryError(string, string) *AppTheoryError

func OriginURL(map[string][]string) string

func RateLimitMiddleware(RateLimitConfig) Middleware

func RequireAuth() RouteOption

func SSEResponse(int, ...SSEEvent) (*Response, error)

func SSEStreamResponse(context.Context, int, <-chan SSEEvent) (*Response, error)

func SafeJSONForHTML(any) (string, error)

func StepFunctionsTaskToken(any) string

func StreamBytes(...[]byte) BodyStream

func StreamError(error) BodyStream

func Text(int, string) *Response

func TimeoutMiddleware(TimeoutConfig) Middleware

func Vary([]string, ...string) []string

func WithAuthHook(AuthHook) Option

func WithCORS(CORSConfig) Option

func WithClock(Clock) Option

func WithIDGenerator(IDGenerator) Option

func WithLimits(Limits) Option

func WithObservability(ObservabilityHooks) Option

func WithPolicyHook(PolicyHook) Option

func WithTier(Tier) Option

func WithWebSocketClientFactory(WebSocketClientFactory) Option

func WithWebSocketSupport() Option

func (*App) Delete(string, Handler, ...RouteOption) *App

func (*App) DeleteStrict(string, Handler, ...RouteOption) (*App, error)

func (*App) DynamoDB(string, DynamoDBStreamHandler) *App

func (*App) EventBridge(EventBridgeSelector, EventBridgeHandler) *App

func (*App) Get(string, Handler, ...RouteOption) *App

func (*App) GetStrict(string, Handler, ...RouteOption) (*App, error)

func (*App) Handle(string, string, Handler, ...RouteOption) *App

func (*App) HandleLambda(context.Context, json.RawMessage) (any, error)

func (*App) HandleStrict(string, string, Handler, ...RouteOption) (*App, error)

func (*App) IsLambda() bool

func (*App) Kinesis(string, KinesisHandler) *App

func (*App) Options(string, Handler, ...RouteOption) *App

func (*App) OptionsStrict(string, Handler, ...RouteOption) (*App, error)

func (*App) Patch(string, Handler, ...RouteOption) *App

func (*App) PatchStrict(string, Handler, ...RouteOption) (*App, error)

func (*App) Post(string, Handler, ...RouteOption) *App

func (*App) PostStrict(string, Handler, ...RouteOption) (*App, error)

func (*App) Put(string, Handler, ...RouteOption) *App

func (*App) PutStrict(string, Handler, ...RouteOption) (*App, error)

func (*App) SNS(string, SNSHandler) *App

func (*App) SQS(string, SQSHandler) *App

func (*App) Serve(context.Context, Request) Response

func (*App) ServeALB(context.Context, events.ALBTargetGroupRequest) events.ALBTargetGroupResponse

func (*App) ServeAPIGatewayProxy(context.Context, events.APIGatewayProxyRequest) events.APIGatewayProxyResponse

func (*App) ServeAPIGatewayV2(context.Context, events.APIGatewayV2HTTPRequest) events.APIGatewayV2HTTPResponse

func (*App) ServeDynamoDBStream(context.Context, events.DynamoDBEvent) events.DynamoDBEventResponse

func (*App) ServeEventBridge(context.Context, events.EventBridgeEvent) (any, error)

func (*App) ServeKinesis(context.Context, events.KinesisEvent) events.KinesisEventResponse

func (*App) ServeLambdaFunctionURL(context.Context, events.LambdaFunctionURLRequest) events.LambdaFunctionURLResponse

func (*App) ServeSNS(context.Context, events.SNSEvent) ([]any, error)

func (*App) ServeSQS(context.Context, events.SQSEvent) events.SQSEventResponse

func (*App) ServeWebSocket(context.Context, events.APIGatewayWebsocketProxyRequest) events.APIGatewayProxyResponse

func (*App) Use(Middleware) *App

func (*App) UseEvents(EventMiddleware) *App

func (*App) WebSocket(string, WebSocketHandler) *App

func (*AppError) Error() string

func (*AppTheoryError) Error() string

func (*AppTheoryError) Unwrap() error

func (*AppTheoryError) WithCause(error) *AppTheoryError

func (*AppTheoryError) WithDetails(map[string]any) *AppTheoryError

func (*AppTheoryError) WithRequestID(string) *AppTheoryError

func (*AppTheoryError) WithStackTrace(string) *AppTheoryError

func (*AppTheoryError) WithStatusCode(int) *AppTheoryError

func (*AppTheoryError) WithTimestamp(time.Time) *AppTheoryError

func (*AppTheoryError) WithTraceID(string) *AppTheoryError

func (*Context) AsWebSocket() *WebSocketContext

func (*Context) Context() context.Context

func (*Context) Get(string) any

func (*Context) JSONValue() (any, error)

func (*Context) NewID() string

func (*Context) Now() time.Time

func (*Context) Param(string) string

func (*Context) Set(string, any)

func (*EventContext) Context() context.Context

func (*EventContext) Get(string) any

func (*EventContext) NewID() string

func (*EventContext) Now() time.Time

func (*EventContext) Set(string, any)

func (*WebSocketContext) Context() context.Context

func (*WebSocketContext) NewID() string

func (*WebSocketContext) Now() time.Time

func (*WebSocketContext) SendJSONMessage(any) error

func (*WebSocketContext) SendMessage([]byte) error

func (RandomIDGenerator) NewID() string

func (RealClock) Now() time.Time

## github.com/theory-cloud/apptheory/testkit

type DynamoDBStreamEventOptions struct {
	StreamARN string
	Records   []DynamoDBStreamRecordOptions
}

type DynamoDBStreamRecordOptions struct {
	EventID   string
	EventName string
}

type Env struct {
	Clock *ManualClock
	IDs   *ManualIDGenerator
}

type EventBridgeEventOptions struct {
	ID         string
	Source     string
	DetailType string
	Resources  []string
	Detail     any
	Time       time.Time
	Region     string
	AccountID  string
}

type FakeSNSClient struct {
	mu sync.Mutex

	Calls []SNSPublishCall

	PublishErr error
	nextID     int
}

type FakeStreamerClient struct {
	mu sync.Mutex

	Endpoint string
	Calls    []StreamerCall

	Connections map[string]streamer.Connection

	PostErr   error
	GetErr    error
	DeleteErr error
}

type HTTPEventOptions struct {
	Query        map[string][]string
	Headers      map[string]string
	MultiHeaders map[string][]string
	Cookies      []string
	Body         []byte
	IsBase64     bool
}

type KinesisEventOptions struct {
	StreamARN string
	Records   []KinesisRecordOptions
}

type KinesisRecordOptions struct {
	EventID        string
	EventSourceARN string
	PartitionKey   string
	Data           []byte
}

type ManualClock struct {
	mu  sync.Mutex
	now time.Time
}

type ManualIDGenerator struct {
	mu     sync.Mutex
	prefix string
	next   int64
	queue  []string
}

type SNSEventOptions struct {
	TopicARN string
	Records  []SNSRecordOptions
}

type SNSPublishCall struct {
	TopicARN string
	Subject  string
	Message  string
}

type SNSRecordOptions struct {
	MessageID string
	TopicArn  string
	Subject   string
	Message   string
}

type SQSEventOptions struct {
	QueueARN string
	Records  []SQSMessageOptions
}

type SQSMessageOptions struct {
	MessageID         string
	Body              string
	EventSourceARN    string
	MessageAttributes map[string]events.SQSMessageAttribute
}

type StepFunctionsTaskTokenEventOptions struct {
	TaskToken string
	Payload   map[string]any
}

type StreamResult struct {
	Status          int
	Headers         map[string][]string
	Cookies         []string
	Chunks          [][]byte
	Body            []byte
	IsBase64        bool
	StreamErrorCode string
}

type StreamerCall struct {
	Op           string
	ConnectionID string
	Data         []byte
}

type WebSocketEventOptions struct {
	RouteKey     string
	EventType    string
	ConnectionID string
	DomainName   string
	Stage        string
	RequestID    string
	Body         string
	IsBase64     bool

	Headers               map[string]string
	MultiValueHeaders     map[string][]string
	QueryStringParameters map[string]string
	MultiValueQueryString map[string][]string
}

func ALBTargetGroupRequest(string, string, HTTPEventOptions) events.ALBTargetGroupRequest

func APIGatewayV2Request(string, string, HTTPEventOptions) events.APIGatewayV2HTTPRequest

func DynamoDBStreamEvent(DynamoDBStreamEventOptions) events.DynamoDBEvent

func EventBridgeEvent(EventBridgeEventOptions) events.EventBridgeEvent

func KinesisEvent(KinesisEventOptions) events.KinesisEvent

func LambdaFunctionURLRequest(string, string, HTTPEventOptions) events.LambdaFunctionURLRequest

func New() *Env

func NewFakeSNSClient() *FakeSNSClient

func NewFakeStreamerClient(string) *FakeStreamerClient

func NewManualClock(time.Time) *ManualClock

func NewManualIDGenerator() *ManualIDGenerator

func NewWithTime(time.Time) *Env

func SNSEvent(SNSEventOptions) events.SNSEvent

func SQSEvent(SQSEventOptions) events.SQSEvent

func StepFunctionsTaskTokenEvent(StepFunctionsTaskTokenEventOptions) map[string]any

func WebSocketEvent(WebSocketEventOptions) events.APIGatewayWebsocketProxyRequest

func (*Env) App(...apptheory.Option) *apptheory.App

func (*Env) Invoke(context.Context, *apptheory.App, apptheory.Request) apptheory.Response

func (*Env) InvokeALB(
	context.Context,
	*apptheory.App,
	events.ALBTargetGroupRequest,
) events.ALBTargetGroupResponse

func (*Env) InvokeAPIGatewayV2(
	context.Context,
	*apptheory.App,
	events.APIGatewayV2HTTPRequest,
) events.APIGatewayV2HTTPResponse

func (*Env) InvokeDynamoDBStream(
	context.Context,
	*apptheory.App,
	events.DynamoDBEvent,
) events.DynamoDBEventResponse

func (*Env) InvokeEventBridge(
	context.Context,
	*apptheory.App,
	events.EventBridgeEvent,
) (any, error)

func (*Env) InvokeKinesis(
	context.Context,
	*apptheory.App,
	events.KinesisEvent,
) events.KinesisEventResponse

func (*Env) InvokeLambdaFunctionURL(
	context.Context,
	*apptheory.App,
	events.LambdaFunctionURLRequest,
) events.LambdaFunctionURLResponse

func (*Env) InvokeSNS(context.Context, *apptheory.App, events.SNSEvent) ([]any, error)

func (*Env) InvokeSQS(context.Context, *apptheory.App, events.SQSEvent) events.SQSEventResponse

func (*Env) InvokeStreaming(context.Context, *apptheory.App, apptheory.Request) StreamResult

func (*Env) InvokeWebSocket(
	context.Context,
	*apptheory.App,
	events.APIGatewayWebsocketProxyRequest,
) events.APIGatewayProxyResponse

func (*FakeSNSClient) Publish(
	context.Context,
	*sns.PublishInput,
	...func(*sns.Options),
) (*sns.PublishOutput, error)

func (*FakeStreamerClient) DeleteConnection(context.Context, string) error

func (*FakeStreamerClient) GetConnection(context.Context, string) (streamer.Connection, error)

func (*FakeStreamerClient) PostToConnection(context.Context, string, []byte) error

func (*ManualClock) Advance(time.Duration) time.Time

func (*ManualClock) Now() time.Time

func (*ManualClock) Set(time.Time)

func (*ManualIDGenerator) NewID() string

func (*ManualIDGenerator) Queue(...string)

func (*ManualIDGenerator) Reset()
